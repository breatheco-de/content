# Context + useReducer vs Zustand

Si vienes de Kotlin o Swift, estás acostumbrado a elegir entre diferentes herramientas de estado: en Android tienes ViewModel + LiveData/Flow, Hilt para DI, o tal vez Redux. En iOS tienes Combine, @State/@ObservedObject, o arquitecturas como TCA. React Native tiene sus propias opciones, y elegir la correcta puede ahorrarte muchos dolores de cabeza.

Este artículo te ayudará a decidir entre las dos opciones más populares: Context API + useReducer (nativo de React) y Zustand (librería de 1KB). También veremos cuándo tiene sentido combinar ambas en aplicaciones empresariales.

## Context + useReducer: La Solución Nativa

**Context API** es como un singleton accesible desde cualquier componente, sin necesidad de pasar props. Es el mecanismo nativo de React para compartir estado globalmente.

**useReducer** es similar a Redux pero integrado en React. Si conoces Redux de Android, es prácticamente lo mismo: un reducer recibe estado actual + acción, devuelve nuevo estado.

### Implementación Básica

```javascript
// store/AppContext.js
import { createContext, useReducer, useContext } from 'react';

const AppContext = createContext();

// El reducer: lógica centralizada de cambios
function appReducer(state, action) {
  switch (action.type) {
    case 'LOGIN':
      return { ...state, user: action.payload, isAuthenticated: true };
    
    case 'LOGOUT':
      return { ...state, user: null, isAuthenticated: false };
    
    case 'ADD_TO_CART':
      return { ...state, cart: [...state.cart, action.payload] };
    
    case 'REMOVE_FROM_CART':
      return { 
        ...state, 
        cart: state.cart.filter(item => item.id !== action.payload) 
      };
    
    default:
      return state;
  }
}

const initialState = {
  user: null,
  isAuthenticated: false,
  cart: [],
  products: []
};

export function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

export const useAppContext = () => useContext(AppContext);
```

**Uso en componentes:**

```javascript
// En tu App.js
export default function App() {
  return (
    <AppProvider>
      <Navigation />
    </AppProvider>
  );
}

// En cualquier componente
function CartScreen() {
  const { state, dispatch } = useAppContext();
  
  const addItem = (product) => {
    dispatch({ type: 'ADD_TO_CART', payload: product });
  };
  
  return (
    <View>
      <Text>Items: {state.cart.length}</Text>
      <Button title="Agregar" onPress={() => addItem(product)} />
    </View>
  );
}
```

### Ventajas de Context + useReducer

- **Cero dependencias externas**: Viene con React asi que no instalas nada, no hay actualizaciones de librerías que trackear.

- **TypeScript friendly**: Los tipos de acciones son fáciles de definir y tienes `IntelliSense` completo para ]`action.type`.

- **DevTools de React**: Se integra naturalmente con React DevTools y puedes ver el estado en el árbol de componentes.

### Desventajas de Context + useReducer

- **Re-renders de todo el contexto**

Este es el problema más grave:

```javascript
const { state, dispatch } = useAppContext();

// Este componente se re-renderiza cuando CUALQUIER parte de state cambia
// Aunque solo use state.cart, si state.user cambia, se re-renderiza igual
```

**Por qué pasa esto:** JavaScript compara por referencia. Cuando el reducer retorna un nuevo estado, aunque solo cambies `user`, el objeto `state` es completamente nuevo. Todos los componentes que consumen el contexto ven un cambio.

**Solución parcial:** Dividir en múltiples contexts

```javascript
// contexts/AuthContext.js
export function AuthProvider({ children }) {
  const [authState, dispatch] = useReducer(authReducer, { user: null });
  return <AuthContext.Provider value={{ authState, dispatch }}>{children}</AuthContext.Provider>;
}

// contexts/CartContext.js
export function CartProvider({ children }) {
  const [cartState, dispatch] = useReducer(cartReducer, { cart: [] });
  return <CartContext.Provider value={{ cartState, dispatch }}>{children}</CartContext.Provider>;
}

// App.js
<AuthProvider>
  <CartProvider>
    <Navigation />
  </CartProvider>
</AuthProvider>
```

Ahora los cambios en auth no afectan componentes que solo usan `cart`. Pero esto agrega complejidad.

- **Boilerplate**: Necesitas definir action types como strings, crear action creators para type safety, escribir el switch statement en el reducer y crear el context, provider, y hook personalizado.

- **No hay selectores optimizados**: No puedes suscribirte a una parte específica del estado, sino que vas a necesitar combinar con `useMemo` manualmente.

## Zustand: El Contendiente Ligero

Zustand es una librería de estado mínima (1KB) que resuelve los problemas de Context con una API más simple. El nombre viene del alemán "estado".

**Filosofía:** Estado global sin Context, selectores optimizados por defecto, mínimo boilerplate.

### Implementación Básica

```javascript
// store/useStore.js
import create from 'zustand';

export const useStore = create((set, get) => ({
  // Estado inicial
  user: null,
  isAuthenticated: false,
  cart: [],
  products: [],
  
  // Acciones (sin action types!)
  login: (user) => set({ user, isAuthenticated: true }),
  
  logout: () => set({ user: null, isAuthenticated: false }),
  
  addToCart: (product) => set((state) => ({
    cart: [...state.cart, product]
  })),
  
  removeFromCart: (productId) => set((state) => ({
    cart: state.cart.filter(item => item.id !== productId)
  })),
  
  // Acciones que usan el estado actual
  clearCart: () => {
    const state = get();
    console.log(`Vaciando carrito con ${state.cart.length} items`);
    set({ cart: [] });
  }
}));
```

**Uso en componentes:**

```javascript
function CartScreen() {
  // Selector: solo se re-renderiza cuando cart cambia
  const cart = useStore((state) => state.cart);
  const addToCart = useStore((state) => state.addToCart);
  
  return (
    <View>
      <Text>Items: {cart.length}</Text>
      <Button title="Agregar" onPress={() => addToCart(product)} />
    </View>
  );
}

// Otro componente
function UserProfile() {
  // Este componente SOLO se re-renderiza cuando user cambia
  // Le da igual si cart se modifica
  const user = useStore((state) => state.user);
  
  return <Text>{user?.name}</Text>;
}
```

### Ventajas de Zustand

- **Selectores optimizados por defecto**

Cada componente se suscribe solo a lo que necesita:

```javascript
// Solo se re-renderiza si cart.length cambia (no el contenido del cart)
const cartCount = useStore((state) => state.cart.length);

// Solo si el nombre del usuario cambia
const userName = useStore((state) => state.user?.name);
```

- **Cero boilerplate**: No hay action `types`, no hay reducers con `switch`, no hay `providers` que envolver, ni hay hooks personalizados que crear.

- **API simple e intuitiva**

```javascript
// Context + useReducer
dispatch({ type: 'ADD_TO_CART', payload: product });

// Zustand
addToCart(product);
```

- **Excelente performance en React Native**: Cada selector es una suscripción independiente, no hay re-renders innecesarios y crucial para mantener `60fps` en animaciones.

### Desventajas de Zustand

- **Dependencia externa**: 1KB es poco, pero es una dependencia más, necesitas mantenerla actualizada por otro lado agregar Zustand a proyectos legacy puede requerir aprobación.

## El problema y la solución de la comparación superficial en Zustand

En **JavaScript**, los objetos se comparan por **referencia**, no por contenido.  
Esto significa que aunque dos objetos tengan los mismos datos, **JavaScript los considera distintos**:

```js
{} !== {} // true
```

Por eso, cuando en Zustand seleccionas varios valores del estado y los agrupas en un solo objeto, React piensa que cambió todo el objeto aunque internamente nada haya cambiado.

### ⚠️ El problema

```javascript
// ❌ MALO: Re-renderiza SIEMPRE
function CartSummary() {
  const { cart, user } = useStore((state) => ({
    cart: state.cart,
    user: state.user
  }));
  
  // Problema: { cart: ..., user: ... } es un NUEVO objeto cada vez
  // Aunque cart y user no cambien, el objeto contenedor sí
}
```

Cada vez que el estado global cambia, este componente se vuelve a renderizar, aunque ni cart ni user hayan cambiado, porque el objeto { cart, user } es nuevo en memoria.

**Solución: shallow comparison**

Zustand ofrece una función llamada shallow que realiza una comparación superficial (shallow equality). Esto significa que revisa si las propiedades internas cambiaron, no si el objeto completo es una nueva referencia.

```javascript
import { shallow } from 'zustand/shallow';

// ✅ BUENO: Solo re-renderiza si cart O user cambian
function CartSummary() {
  const { cart, user } = useStore(
    (state) => ({ cart: state.cart, user: state.user }),
    shallow  // Compara propiedades del objeto, no el objeto mismo
  );
}
```

Con esto, el componente solo se actualiza cuando realmente hay un cambio en `cart` o `user`.


## Conclusión

Zustand te ahorrará dolores de cabeza. Los selectores optimizados y menos boilerplate hacen la diferencia.

